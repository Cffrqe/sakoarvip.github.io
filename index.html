<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sakoar Studio</title>
    <style>
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #252526;
            --bg-header: #333333;
            --accent: #d35400; /* Sakoar Orange */
            --accent-hover: #e67e22;
            --text-main: #f0f0f0;
            --border: #3e3e42;
            --input-bg: #3c3c3c;
        }
        body { margin: 0; overflow: hidden; background: var(--bg-dark); color: var(--text-main); font-family: 'Segoe UI', sans-serif; font-size: 12px; display: flex; flex-direction: column; height: 100vh; }
        
        /* HEADER */
        #toolbar { height: 40px; background: var(--bg-header); display: flex; align-items: center; padding: 0 10px; border-bottom: 1px solid var(--border); gap: 10px; }
        .brand { font-weight: 800; font-size: 14px; color: var(--accent); letter-spacing: 1px; margin-right: 15px; }
        
        /* LAYOUT */
        #workspace { display: flex; flex: 1; height: calc(100vh - 240px); } /* Space for bottom panel */
        .panel { background: var(--bg-panel); display: flex; flex-direction: column; border-right: 1px solid var(--border); }
        #hierarchy { width: 220px; }
        #scene { flex: 1; position: relative; background: #111; overflow: hidden; }
        #inspector { width: 280px; border-left: 1px solid var(--border); border-right: none; overflow-y: auto; }
        
        /* BOTTOM PANEL (ASSETS) */
        #assets-panel { height: 200px; background: #1e1e1e; border-top: 1px solid var(--border); display: flex; }
        #script-list { width: 200px; border-right: 1px solid var(--border); overflow-y: auto; background: var(--bg-panel); }
        #script-editor-container { flex: 1; display: flex; flex-direction: column; }
        textarea.code-editor { flex: 1; background: #141414; color: #dcdcdc; border: none; padding: 10px; font-family: 'Consolas', monospace; resize: none; outline: none; }

        /* UI COMPONENTS */
        .panel-header { padding: 8px; background: #303031; font-weight: bold; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
        .btn { background: #444; border: 1px solid #555; color: white; padding: 4px 10px; cursor: pointer; border-radius: 3px; }
        .btn:hover { background: #555; }
        .btn.primary { background: var(--accent); border-color: var(--accent); }
        .btn.active { background: #fff; color: #000; }
        
        input, select { background: var(--input-bg); border: 1px solid #555; color: white; padding: 4px; width: 100%; box-sizing: border-box; margin-bottom: 5px; }
        
        .tree-item { padding: 4px 8px; cursor: pointer; display: flex; align-items: center; }
        .tree-item:hover { background: #333; }
        .tree-item.selected { background: #444; border-left: 3px solid var(--accent); }
        .tree-item.group { color: #aaa; font-style: italic; }

        .prop-row { display: flex; align-items: center; margin-bottom: 6px; }
        .prop-row label { width: 80px; color: #aaa; }

        /* GIZMO OVERLAY */
        #gizmo-layer { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; }
        
        /* MODAL */
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <!-- TOOLBAR -->
    <div id="toolbar">
        <div class="brand">Sakoar Studio</div>
        <button class="btn primary" onclick="Game.togglePlay()" id="btn-play">‚ñ∂ Play</button>
        <button class="btn" onclick="Game.stop()" id="btn-stop">‚ñ† Stop</button>
        <div style="width:1px; height:20px; background:#555; margin:0 5px;"></div>
        <button class="btn" onclick="Editor.saveProject()">üíæ Save JSON</button>
        <label class="btn" style="margin:0;">üìÇ Load JSON <input type="file" id="file-upload" style="display:none" onchange="Editor.loadProject(this)"></label>
        <div style="flex:1"></div>
        <select style="width:100px" id="create-menu" onchange="Editor.spawn(this.value); this.value='';">
            <option value="">+ Create Object...</option>
            <option value="group">üìÅ Empty Group</option>
            <option value="box">‚¨ú Box</option>
            <option value="circle">‚ö™ Circle</option>
            <option value="sprite">üñºÔ∏è Image/Sprite</option>
            <option value="weapon">üî´ Weapon Template</option>
        </select>
    </div>

    <!-- MAIN WORKSPACE -->
    <div id="workspace">
        
        <!-- HIERARCHY -->
        <div id="hierarchy" class="panel">
            <div class="panel-header">
                <span>Hierarchy</span>
                <button class="btn" style="padding:0 5px;" onclick="Editor.refreshHierarchy()">‚Üª</button>
            </div>
            <div id="hierarchy-content" style="flex:1; overflow-y:auto;"></div>
        </div>

        <!-- SCENE -->
        <div id="scene">
            <canvas id="gizmo-layer"></canvas>
        </div>

        <!-- INSPECTOR -->
        <div id="inspector" class="panel">
            <div class="panel-header">Inspector</div>
            <div id="insp-content" class="hidden" style="padding:10px;">
                <div class="prop-row"><label>Name</label><input type="text" id="insp-name"></div>
                <div class="prop-row"><label>Parent</label><select id="insp-parent"></select></div>
                
                <hr style="border:0; border-top:1px solid #444; margin:10px 0;">
                
                <div style="font-weight:bold; margin-bottom:5px;">Transform</div>
                <div class="prop-row"><label>X</label><input type="number" id="insp-x"></div>
                <div class="prop-row"><label>Y</label><input type="number" id="insp-y"></div>
                <div class="prop-row"><label>Rotation</label><input type="number" step="0.1" id="insp-angle"></div>
                <div class="prop-row"><label>Scale</label><input type="number" step="0.1" id="insp-scale" value="1"></div>

                <hr style="border:0; border-top:1px solid #444; margin:10px 0;">
                
                <div style="font-weight:bold; margin-bottom:5px;">Visuals</div>
                <div class="prop-row"><label>Color</label><input type="color" id="insp-color"></div>
                <div class="prop-row"><label>Image URL</label><input type="text" id="insp-texture" placeholder="https://..."></div>

                <hr style="border:0; border-top:1px solid #444; margin:10px 0;">
                
                <div style="font-weight:bold; margin-bottom:5px;">Logic</div>
                <div class="prop-row"><label>Attached Script</label>
                    <select id="insp-script-select">
                        <option value="">(None)</option>
                    </select>
                </div>

                <button class="btn" style="width:100%; background:#c0392b; margin-top:20px;" onclick="Editor.deleteSelected()">Delete Object</button>
            </div>
            <div id="insp-empty" style="padding:20px; text-align:center; color:#666;">Select an object</div>
        </div>
    </div>

    <!-- ASSETS / SCRIPTS -->
    <div id="assets-panel">
        <div id="script-list">
            <div class="panel-header">
                <span>Scripts</span>
                <button class="btn" onclick="Scripts.createNew()">+</button>
            </div>
            <div id="script-list-content"></div>
        </div>
        <div id="script-editor-container">
            <div class="panel-header">
                <span id="script-editor-title">No Script Selected</span>
                <button class="btn primary" onclick="Scripts.saveCurrent()">Save Script</button>
            </div>
            <textarea id="code-editor" class="code-editor" disabled></textarea>
        </div>
    </div>

    <!-- LIB -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <script>
        // --- CORE ENGINE ---
        const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner, 
              Bodies = Matter.Bodies, Composite = Matter.Composite, Events = Matter.Events, 
              Body = Matter.Body, Mouse = Matter.Mouse, MouseConstraint = Matter.MouseConstraint;

        const engine = Engine.create();
        const world = engine.world;
        const container = document.getElementById('scene');
        
        // Renderer
        const render = Render.create({
            element: container,
            engine: engine,
            options: {
                width: container.clientWidth,
                height: container.clientHeight,
                background: '#111',
                wireframes: false,
                showAngleIndicator: false
            }
        });

        // Input
        const mouse = Mouse.create(render.canvas);
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: { stiffness: 0.2, render: { visible: false } }
        });
        Composite.add(world, mouseConstraint);
        
        // Remove wheel events to prevent scrolling
        mouse.element.removeEventListener("mousewheel", mouse.mousewheel);
        mouse.element.removeEventListener("DOMMouseScroll", mouse.mousewheel);

        // Resize
        window.addEventListener('resize', () => {
            render.canvas.width = container.clientWidth;
            render.canvas.height = container.clientHeight;
        });

        // --- SCRIPT MANAGER ---
        const Scripts = {
            library: {}, // Stores code string: { "PlayerMove": "code..." }
            currentEdit: null,
            compiled: {}, // Stores executable functions

            init: function() {
                // Default Samples
                this.library['Rotator'] = `// Simple Rotation\nbody.angle += 0.05;`;
                this.library['PlayerMovement'] = `// WASD Control\nconst speed = 5;\nif(input.keys['w']) Body.setVelocity(body, {x: body.velocity.x, y: -speed});\nif(input.keys['a']) Body.setVelocity(body, {x: -speed, y: body.velocity.y});\nif(input.keys['s']) Body.setVelocity(body, {x: body.velocity.x, y: speed});\nif(input.keys['d']) Body.setVelocity(body, {x: speed, y: body.velocity.y});`;
                this.library['Gun'] = `// Click to Shoot\nif(input.mouseDown && time % 10 === 0) {\n    // Create bullet\n    const b = Bodies.circle(body.position.x, body.position.y, 5, { render: { fillStyle: 'yellow' }});\n    // Shoot towards mouse\n    const force = 0.02;\n    const dx = input.mouseX - body.position.x;\n    const dy = input.mouseY - body.position.y;\n    const mag = Math.sqrt(dx*dx + dy*dy);\n    Body.applyForce(b, b.position, { x: (dx/mag)*force, y: (dy/mag)*force });\n    Composite.add(engine.world, b);\n}`;
                this.renderList();
            },

            createNew: function() {
                const name = prompt("Script Name:", "NewScript");
                if(name) {
                    this.library[name] = "// Write your code here.\n// Available: body, engine, input, time, Body, Composite, Bodies";
                    this.renderList();
                    this.edit(name);
                }
            },

            edit: function(name) {
                this.currentEdit = name;
                document.getElementById('script-editor-title').innerText = "Editing: " + name;
                const area = document.getElementById('code-editor');
                area.value = this.library[name];
                area.disabled = false;
            },

            saveCurrent: function() {
                if(this.currentEdit) {
                    this.library[this.currentEdit] = document.getElementById('code-editor').value;
                    // Recompile
                    try {
                        // Validate syntax
                        new Function('body', 'engine', 'input', 'time', 'Body', 'Composite', 'Bodies', this.library[this.currentEdit]);
                        alert("Script Saved & Compiled!");
                    } catch(e) {
                        alert("Error in script: " + e.message);
                    }
                }
            },

            renderList: function() {
                const list = document.getElementById('script-list-content');
                list.innerHTML = '';
                Object.keys(this.library).forEach(name => {
                    const div = document.createElement('div');
                    div.className = 'tree-item';
                    div.innerText = "üìú " + name;
                    div.onclick = () => this.edit(name);
                    list.appendChild(div);
                });
                
                // Update Inspector Dropdown
                const sel = document.getElementById('insp-script-select');
                const currentVal = sel.value;
                sel.innerHTML = '<option value="">(None)</option>';
                Object.keys(this.library).forEach(name => {
                    const opt = document.createElement('option');
                    opt.value = name;
                    opt.innerText = name;
                    sel.appendChild(opt);
                });
                sel.value = currentVal;
            },

            run: function(body) {
                if(!body.sakoar || !body.sakoar.script) return;
                const name = body.sakoar.script;
                const code = this.library[name];
                if(!code) return;

                if(!this.compiled[name]) {
                    try {
                        this.compiled[name] = new Function('body', 'engine', 'input', 'time', 'Body', 'Composite', 'Bodies', code);
                    } catch(e) { console.error(e); return; }
                }
                
                try {
                    this.compiled[name](body, engine, Game.input, Game.frameCount, Body, Composite, Bodies);
                } catch(e) {
                    console.error("Runtime Error in " + name, e);
                }
            }
        };

        // --- EDITOR LOGIC ---
        const Editor = {
            selected: null,
            clipboard: null,

            spawn: function(type) {
                if(!type) return;
                const cx = container.clientWidth/2;
                const cy = container.clientHeight/2;
                let b;

                if(type === 'group') {
                    // Logic group
                    b = Composite.create({ label: 'New Group' });
                    Composite.add(world, b);
                    this.refreshHierarchy();
                    return;
                }
                else if(type === 'box') {
                    b = Bodies.rectangle(cx, cy, 50, 50, { render: { fillStyle: '#3498db' } });
                }
                else if(type === 'circle') {
                    b = Bodies.circle(cx, cy, 30, { render: { fillStyle: '#e74c3c' } });
                }
                else if(type === 'sprite') {
                    b = Bodies.rectangle(cx, cy, 64, 64, { 
                        render: { 
                            sprite: { texture: 'https://labs.phaser.io/assets/sprites/phaser-dude.png', xScale:1, yScale:1 } 
                        } 
                    });
                }
                else if(type === 'weapon') {
                    b = Bodies.rectangle(cx, cy, 40, 10, { render: { fillStyle: '#2ecc71' } });
                    b.sakoar = { script: 'Gun' }; // Auto attach script
                }

                if(b) {
                    b.label = "New " + type;
                    b.sakoar = b.sakoar || { script: "" }; // Custom data container
                    Composite.add(world, b);
                    this.select(b);
                    this.refreshHierarchy();
                }
            },

            select: function(obj) {
                this.selected = obj;
                const ui = document.getElementById('insp-content');
                const empty = document.getElementById('insp-empty');
                
                if(!obj) { ui.classList.add('hidden'); empty.classList.remove('hidden'); return; }
                
                ui.classList.remove('hidden');
                empty.classList.add('hidden');

                // Populate UI
                const isBody = obj.type === 'body';
                
                document.getElementById('insp-name').value = obj.label || 'Unnamed';
                
                if(isBody) {
                    document.getElementById('insp-x').value = Math.round(obj.position.x);
                    document.getElementById('insp-y').value = Math.round(obj.position.y);
                    document.getElementById('insp-angle').value = obj.angle.toFixed(2);
                    document.getElementById('insp-scale').value = obj.render.sprite.xScale || 1;
                    document.getElementById('insp-color').value = obj.render.fillStyle;
                    document.getElementById('insp-texture').value = obj.render.sprite ? (obj.render.sprite.texture || "") : "";
                    
                    // Script
                    obj.sakoar = obj.sakoar || {};
                    document.getElementById('insp-script-select').value = obj.sakoar.script || "";
                }
                
                // Parent selector
                const pSel = document.getElementById('insp-parent');
                pSel.innerHTML = '<option value="world">World</option>';
                // Find all composites
                const traverse = (comp) => {
                    if(comp.id !== world.id) {
                         const opt = document.createElement('option');
                         opt.value = comp.id;
                         opt.innerText = comp.label;
                         pSel.appendChild(opt);
                    }
                    comp.composites.forEach(traverse);
                };
                traverse(world);
            },

            applyProp: function(key, val) {
                if(!this.selected || this.selected.type !== 'body') return;
                const b = this.selected;

                if(key === 'name') { b.label = val; this.refreshHierarchy(); }
                if(key === 'x') Body.setPosition(b, { x: parseFloat(val), y: b.position.y });
                if(key === 'y') Body.setPosition(b, { x: b.position.x, y: parseFloat(val) });
                if(key === 'angle') Body.setAngle(b, parseFloat(val));
                if(key === 'scale') { 
                    const s = parseFloat(val); 
                    // Matter.js scaling is permanent, so we need a base. simplified here:
                    // For sprites, we adjust texture scale
                    if(b.render.sprite) { b.render.sprite.xScale = s; b.render.sprite.yScale = s; }
                }
                if(key === 'color') b.render.fillStyle = val;
                if(key === 'texture') {
                    if(val) { b.render.sprite.texture = val; b.render.sprite.xScale = 1; b.render.sprite.yScale = 1; }
                    else { b.render.sprite.texture = null; }
                }
                if(key === 'script') b.sakoar.script = val;
            },

            deleteSelected: function() {
                if(this.selected) {
                    Composite.remove(world, this.selected, true); // Deep remove
                    this.selected = null;
                    this.select(null);
                    this.refreshHierarchy();
                }
            },

            refreshHierarchy: function() {
                const h = document.getElementById('hierarchy-content');
                h.innerHTML = '';
                
                const buildTree = (comp, depth) => {
                    // Items in this composite
                    const items = [...comp.composites, ...comp.bodies];
                    
                    items.forEach(item => {
                        if(item.id === mouseConstraint.constraint.bodyB?.id) return; // Skip mouse tool
                        if(item === mouseConstraint.body) return;

                        const div = document.createElement('div');
                        div.className = 'tree-item ' + (item.type === 'composite' ? 'group' : '');
                        if(this.selected && this.selected.id === item.id) div.classList.add('selected');
                        div.style.paddingLeft = (depth * 15 + 5) + 'px';
                        
                        const icon = item.type === 'composite' ? 'üìÅ ' : (item.render.sprite && item.render.sprite.texture ? 'üñºÔ∏è ' : 'üßä ');
                        div.innerText = icon + (item.label || item.type);
                        
                        div.onclick = (e) => {
                            e.stopPropagation();
                            this.select(item);
                            this.refreshHierarchy(); // re-render to show selection state
                        };
                        h.appendChild(div);

                        if(item.type === 'composite') buildTree(item, depth + 1);
                    });
                };
                
                buildTree(world, 0);
            },

            saveProject: function() {
                // We need to serialize the world + scripts
                // Matter.js serialization is basic, let's do a custom one for our needs
                const data = {
                    scripts: Scripts.library,
                    objects: []
                };

                const serializeBody = (b) => {
                    return {
                        id: b.id,
                        label: b.label,
                        x: b.position.x,
                        y: b.position.y,
                        angle: b.angle,
                        color: b.render.fillStyle,
                        texture: b.render.sprite ? b.render.sprite.texture : null,
                        isStatic: b.isStatic,
                        script: b.sakoar ? b.sakoar.script : ""
                    };
                };

                Composite.allBodies(world).forEach(b => {
                    // Filter out boundaries/mouse
                    if(b.label !== "Ground" && b.label !== "Wall" && b.id !== mouseConstraint.body?.id) {
                         data.objects.push(serializeBody(b));
                    }
                });

                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], {type: "application/json"});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = "MyGame.json";
                a.click();
            },

            loadProject: function(input) {
                const file = input.files[0];
                if(!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        // Clear World
                        Composite.clear(world);
                        Composite.add(world, mouseConstraint);
                        Game.setupBoundaries();

                        // Load Scripts
                        if(data.scripts) {
                            Scripts.library = data.scripts;
                            Scripts.renderList();
                        }

                        // Load Objects
                        if(data.objects) {
                            data.objects.forEach(obj => {
                                let b = Bodies.rectangle(obj.x, obj.y, 50, 50); // generic size
                                
                                // Restore props
                                b.label = obj.label;
                                Body.setAngle(b, obj.angle);
                                Body.setStatic(b, obj.isStatic || false);
                                b.render.fillStyle = obj.color;
                                if(obj.texture) {
                                    b.render.sprite.texture = obj.texture;
                                    b.render.sprite.xScale = 1;
                                    b.render.sprite.yScale = 1;
                                }
                                b.sakoar = { script: obj.script || "" };
                                
                                Composite.add(world, b);
                            });
                        }
                        this.refreshHierarchy();
                        alert("Project Loaded!");
                    } catch(err) {
                        alert("Failed to load: " + err);
                    }
                };
                reader.readAsText(file);
            }
        };

        // --- GAME LOGIC ---
        const Game = {
            running: false,
            runner: Runner.create(),
            frameCount: 0,
            input: { keys: {}, mouseX: 0, mouseY: 0, mouseDown: false },

            init: function() {
                Scripts.init();
                this.setupBoundaries();
                
                // Gizmo Loop
                Events.on(render, 'afterRender', () => {
                    const ctx = document.getElementById('gizmo-layer').getContext('2d');
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    
                    // Draw selection box
                    if(Editor.selected && Editor.selected.type === 'body') {
                        const b = Editor.selected;
                        ctx.strokeStyle = '#d35400';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.translate(b.position.x, b.position.y);
                        ctx.rotate(b.angle);
                        // Approximate bounds based on verts (simplified for gizmo)
                        ctx.rect(-25, -25, 50, 50); 
                        ctx.stroke();
                        ctx.setTransform(1,0,0,1,0,0);
                    }
                });

                // Selection Click
                Events.on(mouseConstraint, 'mousedown', (e) => {
                    const mousePos = e.mouse.position;
                    const bodies = Composite.allBodies(world);
                    const clicked = Matter.Query.point(bodies, mousePos);
                    
                    if(clicked.length > 0) {
                        // ignore walls
                        if(clicked[0].label === "Wall" || clicked[0].label === "Ground") {
                             Editor.select(null);
                        } else {
                             Editor.select(clicked[0]);
                        }
                    } else {
                        Editor.select(null);
                    }
                    Editor.refreshHierarchy();
                });

                // Input Listeners
                window.addEventListener('keydown', e => this.input.keys[e.key] = true);
                window.addEventListener('keyup', e => this.input.keys[e.key] = false);
                window.addEventListener('mousemove', e => {
                    const rect = container.getBoundingClientRect();
                    this.input.mouseX = e.clientX - rect.left;
                    this.input.mouseY = e.clientY - rect.top;
                });
                container.addEventListener('mousedown', () => this.input.mouseDown = true);
                window.addEventListener('mouseup', () => this.input.mouseDown = false);

                // Run Render
                Render.run(render);
                Editor.refreshHierarchy();
            },

            setupBoundaries: function() {
                const w = container.clientWidth;
                const h = container.clientHeight;
                const ground = Bodies.rectangle(w/2, h+30, w, 60, { isStatic: true, label: "Ground", render:{fillStyle:'#333'} });
                const left = Bodies.rectangle(-30, h/2, 60, h, { isStatic: true, label: "Wall" });
                const right = Bodies.rectangle(w+30, h/2, 60, h, { isStatic: true, label: "Wall" });
                Composite.add(world, [ground, left, right]);
            },

            togglePlay: function() {
                this.running = !this.running;
                if(this.running) {
                    document.getElementById('btn-play').innerText = "‚ùö‚ùö Pause";
                    Runner.run(this.runner, engine);
                    // Add update hook for scripts
                    Events.on(engine, 'beforeUpdate', this.updateLoop);
                } else {
                    document.getElementById('btn-play').innerText = "‚ñ∂ Play";
                    Runner.stop(this.runner);
                    Events.off(engine, 'beforeUpdate', this.updateLoop);
                }
            },

            stop: function() {
                this.running = false;
                document.getElementById('btn-play').innerText = "‚ñ∂ Play";
                Runner.stop(this.runner);
                Events.off(engine, 'beforeUpdate', this.updateLoop);
                
                // Reset (Simple reload for now to reset positions, in a full engine we'd store initial states)
                // For this demo, we just stop physics.
                alert("Simulation Stopped. (Note: To reset positions fully, click Reload or Load JSON)");
            },

            updateLoop: function() {
                Game.frameCount++;
                Composite.allBodies(world).forEach(b => Scripts.run(b));
            }
        };

        // UI Binds
        ['name','x','y','angle','scale','color','texture','script-select'].forEach(id => {
            const el = document.getElementById('insp-'+id);
            if(el) {
                el.addEventListener(el.tagName==='SELECT'?'change':'input', (e) => {
                    const key = id === 'script-select' ? 'script' : id;
                    Editor.applyProp(key, e.target.value);
                });
            }
        });

        // Start
        Game.init();

    </script>
</body>
</html>

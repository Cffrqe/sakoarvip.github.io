<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Playground</title>
    
    <!-- CSS is now embedded directly inside the HTML head -->
    <style>
        body {
            background-color: #1a1a1a;
            color: #f0f0f0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            overflow: hidden; /* Hide scrollbars */
        }

        h1 {
            color: #00bcd4;
            text-shadow: 0 0 5px #00bcd4;
        }

        #toolbar {
            background-color: #252525;
            padding: 10px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #333;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap; /* Allows buttons to wrap on smaller screens */
            justify-content: center;
        }

        .tool-button, .danger-button {
            background-color: #333;
            color: #f0f0f0;
            border: 1px solid #555;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tool-button:hover {
            background-color: #444;
            border-color: #777;
        }

        .tool-button.active {
            background-color: #00bcd4;
            color: #1a1a1a;
            border-color: #00bcd4;
            font-weight: bold;
        }

        .danger-button {
            background-color: #d32f2f;
            border-color: #e57373;
        }
        .danger-button:hover {
            background-color: #e53935;
        }

        #game-container {
            border: 2px solid #00bcd4;
            box-shadow: 0 0 15px #00bcd480;
            background-color: #212121;
        }

        /* Make the canvas fit inside the container */
        canvas {
            display: block;
        }
    </style>
</head>
<body>

    <h1>Web Playground</h1>
    
    <div id="toolbar">
        <span>Tool:</span>
        <button id="spawn-box" class="tool-button active">Box</button>
        <button id="spawn-ball" class="tool-button">Ball</button>
        <button id="spawn-ragdoll" class="tool-button">Person</button>
        <button id="tool-rope" class="tool-button">Rope</button>
        <button id="clear-all" class="danger-button">Clear All</button>
    </div>

    <div id="game-container">
        <!-- The Matter.js physics world will be rendered here -->
    </div>

    <!-- Get the Matter.js physics engine from a CDN (Content Delivery Network) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    
    <!-- All of our game logic is now embedded directly in this script tag -->
    <script>
        // --- MODULE ALIASES ---
        const Engine = Matter.Engine;
        const Render = Matter.Render;
        const Runner = Matter.Runner;
        const World = Matter.World;
        const Bodies = Matter.Bodies;
        const Mouse = Matter.Mouse;
        const MouseConstraint = Matter.MouseConstraint;
        const Composite = Matter.Composite;
        const Composites = Matter.Composites;
        const Constraint = Matter.Constraint;

        // --- GAME SETUP ---

        // Get the container element
        const gameContainer = document.getElementById('game-container');
        const width = 800;
        const height = 600;

        // Create an engine
        const engine = Engine.create();
        const world = engine.world;

        // Create a renderer
        const render = Render.create({
            element: gameContainer,
            engine: engine,
            options: {
                width: width,
                height: height,
                wireframes: false, // Set to false for solid colors
                background: '#212121'
            }
        });

        // Create a runner
        const runner = Runner.create();

        // Run the renderer and the engine
        Render.run(render);
        Runner.run(runner, engine);

        // --- ADDING WALLS AND GROUND ---

        const wallOptions = { isStatic: true, render: { fillStyle: '#00bcd4' } };
        World.add(world, [
            Bodies.rectangle(width / 2, 0, width, 50, wallOptions), // Top wall
            Bodies.rectangle(width / 2, height, width, 50, wallOptions), // Ground
            Bodies.rectangle(0, height / 2, 50, height, wallOptions), // Left wall
            Bodies.rectangle(width, height / 2, 50, height, wallOptions)  // Right wall
        ]);

        // --- MOUSE INTERACTION ---

        // Add mouse control for dragging objects
        const mouse = Mouse.create(render.canvas);
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.2,
                render: {
                    visible: false
                }
            }
        });
        World.add(world, mouseConstraint);

        // --- TOOLBAR LOGIC ---

        let currentTool = 'spawn-box';
        let ropeStart = null; // Variable to store the first body for the rope

        const toolButtons = document.querySelectorAll('.tool-button');
        toolButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Deactivate all buttons
                toolButtons.forEach(btn => btn.classList.remove('active'));
                // Activate the clicked button
                button.classList.add('active');
                currentTool = button.id;
                ropeStart = null; // Reset rope tool when switching
            });
        });

        // --- SPAWNING LOGIC ---

        function spawnObject(x, y) {
            switch (currentTool) {
                case 'spawn-box':
                    const box = Bodies.rectangle(x, y, 50, 50, {
                        render: { fillStyle: getRandomColor() }
                    });
                    World.add(world, box);
                    break;
                case 'spawn-ball':
                    const ball = Bodies.circle(x, y, 25, {
                        restitution: 0.7, // Make it bouncy
                        render: { fillStyle: getRandomColor() }
                    });
                    World.add(world, ball);
                    break;
                case 'spawn-ragdoll':
                    spawnRagdoll(x, y);
                    break;
            }
        }

        // Function to create a "person" (a simple ragdoll)
        function spawnRagdoll(x, y) {
            const group = Matter.Body.nextGroup(true);
            const head = Bodies.circle(x, y - 60, 20, { collisionFilter: { group: group }, render: { fillStyle: '#ffc107' } });
            const torso = Bodies.rectangle(x, y, 40, 70, { collisionFilter: { group: group }, render: { fillStyle: '#4caf50' } });
            
            // Connect head to torso
            const neck = Constraint.create({
                bodyA: head,
                bodyB: torso,
                pointA: { x: 0, y: 20 },
                pointB: { x: 0, y: -35 },
                stiffness: 0.8,
                length: 2
            });
            
            // Create limbs (simple boxes for now)
            const leftArm = Bodies.rectangle(x - 40, y, 20, 50, { collisionFilter: { group: group }, render: { fillStyle: '#2196f3' } });
            const rightArm = Bodies.rectangle(x + 40, y, 20, 50, { collisionFilter: { group: group }, render: { fillStyle: '#2196f3' } });
            
            // Connect arms
            const leftShoulder = Constraint.create({ bodyA: torso, bodyB: leftArm, pointA: {x: -20, y: -25}, pointB: {x: 0, y: -15}, stiffness: 0.5 });
            const rightShoulder = Constraint.create({ bodyA: torso, bodyB: rightArm, pointA: {x: 20, y: -25}, pointB: {x: 0, y: -15}, stiffness: 0.5 });

            const ragdoll = Composite.create({
                bodies: [torso, head, leftArm, rightArm],
                constraints: [neck, leftShoulder, rightShoulder]
            });

            World.add(world, ragdoll);
        }

        // --- ROPE TOOL LOGIC ---

        function handleRopeTool(clickedBody) {
            if (!ropeStart) {
                // This is the first click, store the body
                ropeStart = clickedBody;
            } else {
                // This is the second click, create the rope
                if (ropeStart !== clickedBody) {
                    const rope = Constraint.create({
                        bodyA: ropeStart,
                        bodyB: clickedBody,
                        stiffness: 0.1,
                        damping: 0.1,
                        render: {
                            strokeStyle: '#ffffff',
                            lineWidth: 2
                        }
                    });
                    World.add(world, rope);
                }
                // Reset for the next rope
                ropeStart = null; 
            }
        }

        // --- EVENT LISTENERS ---

        // Listen for clicks on the canvas
        render.canvas.addEventListener('mousedown', (event) => {
            // Check if we are dragging an object with the mouse constraint; if so, don't spawn anything.
            const isDragging = mouseConstraint.body;
            if (isDragging) return;

            // Get mouse position relative to the canvas
            const rect = render.canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            if (currentTool.startsWith('spawn')) {
                spawnObject(x, y);
            } else if (currentTool === 'tool-rope') {
                const bodies = Composite.allBodies(world);
                const clickedBodies = Matter.Query.point(bodies, { x, y });
                // Only act if we clicked on a dynamic (non-wall) body
                if (clickedBodies.length > 0 && !clickedBodies[0].isStatic) {
                    handleRopeTool(clickedBodies[0]);
                }
            }
        });

        // Clear button
        document.getElementById('clear-all').addEventListener('click', () => {
            // Remove all non-static bodies and all constraints from the world
            World.clear(world);
            Engine.clear(engine);

            // Re-add the walls since they were also cleared
            World.add(world, [
                Bodies.rectangle(width / 2, 0, width, 50, wallOptions),
                Bodies.rectangle(width / 2, height, width, 50, wallOptions),
                Bodies.rectangle(0, height / 2, 50, height, wallOptions),
                Bodies.rectangle(width, height / 2, 50, height, wallOptions)
            ]);

            // Re-add the mouse constraint so dragging still works
            World.add(world, mouseConstraint);
        });

        // --- HELPER FUNCTIONS ---

        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

    </script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebPhys Engine 2.0</title>
    <style>
        :root {
            --bg-dark: #202124;
            --bg-panel: #2d2e32;
            --bg-header: #38393e;
            --accent: #00bcd4;
            --text-main: #e8eaed;
            --text-muted: #9aa0a6;
            --border: #45474d;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-dark);
            color: var(--text-main);
            font-family: 'Segoe UI', sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- HEADER --- */
        #header {
            height: 40px;
            background-color: var(--bg-header);
            display: flex;
            align-items: center;
            padding: 0 15px;
            border-bottom: 1px solid var(--border);
            justify-content: space-between;
        }

        .brand { font-weight: bold; color: var(--accent); letter-spacing: 1px; }

        .play-controls {
            display: flex;
            gap: 10px;
            background: #202124;
            padding: 4px;
            border-radius: 4px;
        }

        .control-btn {
            background: transparent;
            border: none;
            color: var(--text-main);
            cursor: pointer;
            padding: 4px 12px;
            border-radius: 3px;
            font-size: 14px;
        }
        .control-btn:hover { background: #444; }
        .control-btn.active { background: var(--accent); color: #000; }

        /* --- MAIN LAYOUT --- */
        #workspace {
            display: flex;
            flex: 1;
            height: calc(100vh - 40px);
        }

        /* LEFT SIDEBAR (TOOLS) */
        #hierarchy {
            width: 200px;
            background-color: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 10px;
            overflow-y: auto;
        }

        .panel-header {
            font-size: 12px;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 10px;
            font-weight: bold;
        }

        .tool-btn {
            background-color: #3c4043;
            border: 1px solid transparent;
            color: #fff;
            padding: 10px;
            margin-bottom: 5px;
            text-align: left;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tool-btn:hover { background-color: #505459; }
        .tool-btn:active { transform: translateY(1px); }

        /* CENTER (SCENE) */
        #scene-view {
            flex: 1;
            position: relative;
            background-color: #1a1a1a;
            /* Grid Pattern */
            background-image: linear-gradient(#333 1px, transparent 1px), linear-gradient(90deg, #333 1px, transparent 1px);
            background-size: 40px 40px;
            overflow: hidden;
        }

        canvas { display: block; }

        /* RIGHT SIDEBAR (INSPECTOR) */
        #inspector {
            width: 260px;
            background-color: var(--bg-panel);
            border-left: 1px solid var(--border);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .inspector-group {
            background: #38393e;
            padding: 10px;
            border-radius: 5px;
        }

        .prop-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .prop-row label { color: var(--text-muted); }

        input[type="number"], input[type="text"], select {
            background: #202124;
            border: 1px solid #45474d;
            color: white;
            padding: 4px;
            border-radius: 3px;
            width: 60px;
        }

        input[type="color"] {
            background: transparent;
            border: none;
            width: 30px;
            height: 30px;
            cursor: pointer;
        }

        .full-btn {
            width: 100%;
            padding: 8px;
            background: #d93025;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        .full-btn:hover { background: #b0271f; }

        #no-selection {
            color: var(--text-muted);
            font-style: italic;
            text-align: center;
            margin-top: 20px;
        }

        .hidden { display: none; }
    </style>
</head>
<body>

    <!-- Top Toolbar -->
    <div id="header">
        <div class="brand">PHYSICS ENGINE 2.0</div>
        <div class="play-controls">
            <button id="btn-play" class="control-btn" onclick="togglePlayState()">‚ñ∂ Play</button>
            <button id="btn-pause" class="control-btn active" onclick="togglePlayState()">‚ùö‚ùö Edit</button>
            <button class="control-btn" onclick="clearWorld()">üóë Clear Scene</button>
        </div>
        <div style="font-size:12px; color:#aaa;">Unity-Style Web Editor</div>
    </div>

    <!-- Main Workspace -->
    <div id="workspace">
        
        <!-- Hierarchy / Create Menu -->
        <div id="hierarchy">
            <div class="panel-header">Create Objects</div>
            <button class="tool-btn" onclick="spawn('box')">‚¨ú Box</button>
            <button class="tool-btn" onclick="spawn('circle')">‚ö™ Circle</button>
            <button class="tool-btn" onclick="spawn('poly')">‚¨° Polygon</button>
            
            <div class="panel-header" style="margin-top:20px;">Prefabs</div>
            <button class="tool-btn" onclick="spawn('stack')">üì¶ Stack</button>
            <button class="tool-btn" onclick="spawn('ragdoll')">üèÉ Ragdoll</button>
            <button class="tool-btn" onclick="spawn('car')">üöó Car</button>
        </div>

        <!-- Scene View -->
        <div id="scene-view">
            <!-- Canvas is injected here by Matter.js -->
        </div>

        <!-- Inspector -->
        <div id="inspector">
            <div class="panel-header">Inspector</div>
            
            <div id="no-selection">Select an object to edit properties</div>

            <div id="inspector-content" class="hidden">
                <div class="inspector-group">
                    <div class="prop-row">
                        <label>Type</label>
                        <span id="insp-type" style="color:var(--accent)">Body</span>
                    </div>
                </div>

                <div class="inspector-group">
                    <div class="panel-header">Transform</div>
                    <div class="prop-row">
                        <label>Pos X</label>
                        <input type="number" id="insp-x" step="1">
                    </div>
                    <div class="prop-row">
                        <label>Pos Y</label>
                        <input type="number" id="insp-y" step="1">
                    </div>
                    <div class="prop-row">
                        <label>Rotation</label>
                        <input type="number" id="insp-angle" step="0.1">
                    </div>
                </div>

                <div class="inspector-group">
                    <div class="panel-header">Material</div>
                    <div class="prop-row">
                        <label>Color</label>
                        <input type="color" id="insp-color">
                    </div>
                    <div class="prop-row">
                        <label>Is Static</label>
                        <input type="checkbox" id="insp-static">
                    </div>
                    <div class="prop-row">
                        <label>Bounciness</label>
                        <input type="number" id="insp-restitution" step="0.1" min="0" max="1.5">
                    </div>
                    <div class="prop-row">
                        <label>Friction</label>
                        <input type="number" id="insp-friction" step="0.01" min="0" max="1">
                    </div>
                </div>

                <button class="full-btn" onclick="deleteSelected()">Delete Object</button>
            </div>
        </div>
    </div>

    <!-- Matter.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>

    <script>
        // --- ENGINE SETUP ---
        const Engine = Matter.Engine,
              Render = Matter.Render,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Composite = Matter.Composite,
              Composites = Matter.Composites,
              Constraint = Matter.Constraint,
              Mouse = Matter.Mouse,
              MouseConstraint = Matter.MouseConstraint,
              Events = Matter.Events,
              Body = Matter.Body;

        // Init Engine
        const engine = Engine.create();
        const world = engine.world;
        
        // Setup Render
        const sceneView = document.getElementById('scene-view');
        const render = Render.create({
            element: sceneView,
            engine: engine,
            options: {
                width: sceneView.clientWidth,
                height: sceneView.clientHeight,
                wireframes: false,
                background: 'transparent', // Using CSS grid background
                showAngleIndicator: true
            }
        });

        // Setup Resize Handler for Full Screen
        window.addEventListener('resize', () => {
            render.canvas.width = sceneView.clientWidth;
            render.canvas.height = sceneView.clientHeight;
            // Update boundaries if needed (we will use a floor for this demo)
            updateGround();
        });

        // Add Boundaries (Floor and Sides)
        let ground, wallLeft, wallRight;
        function createBoundaries() {
            const w = sceneView.clientWidth;
            const h = sceneView.clientHeight;
            const thickness = 100;

            ground = Bodies.rectangle(w/2, h + 35, w * 2, 100, { isStatic: true, render: { fillStyle: '#333' } });
            wallLeft = Bodies.rectangle(-50, h/2, 100, h * 4, { isStatic: true, render: { visible: false } });
            wallRight = Bodies.rectangle(w + 50, h/2, 100, h * 4, { isStatic: true, render: { visible: false } });
            
            Composite.add(world, [ground, wallLeft, wallRight]);
        }

        function updateGround() {
            const w = sceneView.clientWidth;
            const h = sceneView.clientHeight;
            Body.setPosition(ground, { x: w/2, y: h + 35 });
            Body.setPosition(wallLeft, { x: -50, y: h/2 });
            Body.setPosition(wallRight, { x: w + 50, y: h/2 });
        }

        createBoundaries();

        // --- INTERACTION & SELECTION SYSTEM ---

        const mouse = Mouse.create(render.canvas);
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.2,
                render: { visible: false }
            }
        });
        Composite.add(world, mouseConstraint);

        // Allow scrolling inside the canvas without zooming the page
        mouse.element.removeEventListener("mousewheel", mouse.mousewheel);
        mouse.element.removeEventListener("DOMMouseScroll", mouse.mousewheel);

        let selectedBody = null;
        const inspectorContent = document.getElementById('inspector-content');
        const noSelection = document.getElementById('no-selection');

        // Custom Render Loop to draw Selection Outline (Gizmo)
        Events.on(render, 'afterRender', function() {
            if (selectedBody) {
                const ctx = render.context;
                ctx.beginPath();
                // Draw a simple bounding box or circle around selected item
                const b = selectedBody.bounds;
                const pad = 5;
                ctx.rect(b.min.x - pad, b.min.y - pad, (b.max.x - b.min.x) + pad*2, (b.max.y - b.min.y) + pad*2);
                ctx.strokeStyle = '#00bcd4';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        });

        // Click Handler for Selection
        Events.on(mouseConstraint, 'mousedown', function(event) {
            const mousePosition = event.mouse.position;
            const bodies = Composite.allBodies(world);
            
            // Filter out walls/ground from selection
            const candidateBodies = bodies.filter(b => b !== ground && b !== wallLeft && b !== wallRight);
            const clicked = Matter.Query.point(candidateBodies, mousePosition);

            if (clicked.length > 0) {
                selectObject(clicked[0]);
            } else {
                deselectObject();
            }
        });

        // Sync Inspector values while dragging
        Events.on(engine, 'afterUpdate', function() {
            if (selectedBody && !isPlaying) {
                // If in Edit mode (paused), we still want to move things with mouse, 
                // but physics calculation step is manual. 
                // Matter.js 'Runner' usually stops physics updates when stopped.
                // So this event fires only when running.
            }
            // For continuous update of inspector UI during play
            if (selectedBody) {
                updateInspectorValues();
            }
        });

        function selectObject(body) {
            selectedBody = body;
            noSelection.classList.add('hidden');
            inspectorContent.classList.remove('hidden');
            updateInspectorUI();
        }

        function deselectObject() {
            selectedBody = null;
            noSelection.classList.remove('hidden');
            inspectorContent.classList.add('hidden');
        }

        // --- INSPECTOR LOGIC ---

        const inputs = {
            x: document.getElementById('insp-x'),
            y: document.getElementById('insp-y'),
            angle: document.getElementById('insp-angle'),
            color: document.getElementById('insp-color'),
            static: document.getElementById('insp-static'),
            restitution: document.getElementById('insp-restitution'),
            friction: document.getElementById('insp-friction'),
        };

        // Update UI inputs from Body data
        function updateInspectorUI() {
            if (!selectedBody) return;
            inputs.x.value = Math.round(selectedBody.position.x);
            inputs.y.value = Math.round(selectedBody.position.y);
            inputs.angle.value = selectedBody.angle.toFixed(2);
            inputs.color.value = selectedBody.render.fillStyle;
            inputs.static.checked = selectedBody.isStatic;
            inputs.restitution.value = selectedBody.restitution;
            inputs.friction.value = selectedBody.friction;
        }
        
        // Used in Loop
        function updateInspectorValues() {
            if(document.activeElement.tagName === 'INPUT') return; // Don't overwrite if user is typing
            updateInspectorUI();
        }

        // Apply Input changes to Body
        inputs.x.addEventListener('change', e => Body.setPosition(selectedBody, { x: parseFloat(e.target.value), y: selectedBody.position.y }));
        inputs.y.addEventListener('change', e => Body.setPosition(selectedBody, { x: selectedBody.position.x, y: parseFloat(e.target.value) }));
        inputs.angle.addEventListener('change', e => Body.setAngle(selectedBody, parseFloat(e.target.value)));
        inputs.color.addEventListener('input', e => selectedBody.render.fillStyle = e.target.value);
        inputs.static.addEventListener('change', e => Body.setStatic(selectedBody, e.target.checked));
        inputs.restitution.addEventListener('change', e => selectedBody.restitution = parseFloat(e.target.value));
        inputs.friction.addEventListener('change', e => selectedBody.friction = parseFloat(e.target.value));

        function deleteSelected() {
            if(selectedBody) {
                Composite.remove(world, selectedBody);
                deselectObject();
            }
        }

        // --- GAME LOGIC (PLAY / EDIT) ---

        let isPlaying = false;
        const runner = Runner.create();
        
        // Start renderer immediately so we can see stuff
        Render.run(render);

        function togglePlayState() {
            isPlaying = !isPlaying;
            const btnPlay = document.getElementById('btn-play');
            const btnPause = document.getElementById('btn-pause');

            if (isPlaying) {
                // Start Physics
                Runner.run(runner, engine);
                btnPlay.classList.add('active');
                btnPause.classList.remove('active');
            } else {
                // Stop Physics
                Runner.stop(runner);
                btnPlay.classList.remove('active');
                btnPause.classList.add('active');
            }
        }

        function clearWorld() {
            Composite.clear(world);
            Composite.add(world, [ground, wallLeft, wallRight, mouseConstraint]);
            deselectObject();
        }

        // --- OBJECT SPAWNING ---

        function getRandomColor() {
            return '#' + Math.floor(Math.random()*16777215).toString(16);
        }

        function spawn(type) {
            const x = sceneView.clientWidth / 2;
            const y = sceneView.clientHeight / 2 - 100;
            const color = getRandomColor();
            let body;

            switch(type) {
                case 'box':
                    body = Bodies.rectangle(x, y, 60, 60, { render: { fillStyle: color }});
                    break;
                case 'circle':
                    body = Bodies.circle(x, y, 35, { render: { fillStyle: color }});
                    break;
                case 'poly':
                    body = Bodies.polygon(x, y, 5, 40, { render: { fillStyle: color }});
                    break;
                case 'stack':
                    body = Composites.stack(x - 50, y - 50, 4, 4, 0, 0, function(bx, by) {
                        return Bodies.rectangle(bx, by, 30, 30, { render: { fillStyle: getRandomColor() } });
                    });
                    break;
                case 'ragdoll':
                    spawnRagdoll(x, y);
                    return; // Complex spawn, handled differently
                case 'car':
                    spawnCar(x, y);
                    return;
            }

            if(body) {
                Composite.add(world, body);
            }
        }

        // --- PREFABS ---

        function spawnRagdoll(x, y) {
            const group = Body.nextGroup(true);
            const head = Bodies.circle(x, y - 25, 15, { collisionFilter: { group: group }, render: { fillStyle: '#FFBC42' } });
            const chest = Bodies.rectangle(x, y, 30, 40, { collisionFilter: { group: group }, render: { fillStyle: '#E04F5F' } });
            const rightUpperArm = Bodies.rectangle(x + 18, y - 10, 10, 20, { collisionFilter: { group: group }, render: { fillStyle: '#E04F5F' } });
            const rightLowerArm = Bodies.rectangle(x + 18, y + 15, 10, 20, { collisionFilter: { group: group }, render: { fillStyle: '#E04F5F' } });
            const leftUpperArm = Bodies.rectangle(x - 18, y - 10, 10, 20, { collisionFilter: { group: group }, render: { fillStyle: '#E04F5F' } });
            const leftLowerArm = Bodies.rectangle(x - 18, y + 15, 10, 20, { collisionFilter: { group: group }, render: { fillStyle: '#E04F5F' } });
            const leftUpperLeg = Bodies.rectangle(x - 10, y + 30, 10, 25, { collisionFilter: { group: group }, render: { fillStyle: '#75CAE0' } });
            const leftLowerLeg = Bodies.rectangle(x - 10, y + 60, 10, 25, { collisionFilter: { group: group }, render: { fillStyle: '#75CAE0' } });
            const rightUpperLeg = Bodies.rectangle(x + 10, y + 30, 10, 25, { collisionFilter: { group: group }, render: { fillStyle: '#75CAE0' } });
            const rightLowerLeg = Bodies.rectangle(x + 10, y + 60, 10, 25, { collisionFilter: { group: group }, render: { fillStyle: '#75CAE0' } });

            const chestToHead = Constraint.create({ bodyA: chest, bodyB: head, pointA: { x: 0, y: -20 }, pointB: { x: 0, y: 10 }, stiffness: 0.6 });
            const chestToRightUpperArm = Constraint.create({ bodyA: chest, bodyB: rightUpperArm, pointA: { x: 15, y: -10 }, pointB: { x: 0, y: -10 }, stiffness: 0.6 });
            const chestToLeftUpperArm = Constraint.create({ bodyA: chest, bodyB: leftUpperArm, pointA: { x: -15, y: -10 }, pointB: { x: 0, y: -10 }, stiffness: 0.6 });
            const upperToLowerRightArm = Constraint.create({ bodyA: rightUpperArm, bodyB: rightLowerArm, pointA: { x: 0, y: 10 }, pointB: { x: 0, y: -10 }, stiffness: 0.6 });
            const upperToLowerLeftArm = Constraint.create({ bodyA: leftUpperArm, bodyB: leftLowerArm, pointA: { x: 0, y: 10 }, pointB: { x: 0, y: -10 }, stiffness: 0.6 });
            const chestToLeftLeg = Constraint.create({ bodyA: chest, bodyB: leftUpperLeg, pointA: { x: -10, y: 20 }, pointB: { x: 0, y: -12 }, stiffness: 0.6 });
            const chestToRightLeg = Constraint.create({ bodyA: chest, bodyB: rightUpperLeg, pointA: { x: 10, y: 20 }, pointB: { x: 0, y: -12 }, stiffness: 0.6 });
            const upperToLowerLeftLeg = Constraint.create({ bodyA: leftUpperLeg, bodyB: leftLowerLeg, pointA: { x: 0, y: 12 }, pointB: { x: 0, y: -12 }, stiffness: 0.6 });
            const upperToLowerRightLeg = Constraint.create({ bodyA: rightUpperLeg, bodyB: rightLowerLeg, pointA: { x: 0, y: 12 }, pointB: { x: 0, y: -12 }, stiffness: 0.6 });

            Composite.add(world, [
                head, chest, rightUpperArm, rightLowerArm, leftUpperArm, leftLowerArm, leftUpperLeg, leftLowerLeg, rightUpperLeg, rightLowerLeg,
                chestToHead, chestToRightUpperArm, chestToLeftUpperArm, upperToLowerRightArm, upperToLowerLeftArm, chestToLeftLeg, chestToRightLeg, upperToLowerLeftLeg, upperToLowerRightLeg
            ]);
        }

        function spawnCar(x, y) {
            const group = Body.nextGroup(true);
            const wheelBase = 20;
            const wheelAOffset = -40;
            const wheelBOffset = 40;
            const wheelYOffset = 20;

            const chassis = Bodies.rectangle(x, y, 120, 30, { 
                collisionFilter: { group: group },
                render: { fillStyle: '#C63D3D' }
            });

            const wheelA = Bodies.circle(x + wheelAOffset, y + wheelYOffset, 15, { 
                collisionFilter: { group: group },
                friction: 0.8,
                render: { fillStyle: '#333' }
            });

            const wheelB = Bodies.circle(x + wheelBOffset, y + wheelYOffset, 15, { 
                collisionFilter: { group: group },
                friction: 0.8,
                render: { fillStyle: '#333' }
            });

            const axelA = Constraint.create({
                bodyB: chassis,
                pointB: { x: wheelAOffset, y: wheelYOffset },
                bodyA: wheelA,
                stiffness: 1,
                length: 0
            });

            const axelB = Constraint.create({
                bodyB: chassis,
                pointB: { x: wheelBOffset, y: wheelYOffset },
                bodyA: wheelB,
                stiffness: 1,
                length: 0
            });

            Composite.add(world, [chassis, wheelA, wheelB, axelA, axelB]);
        }

        // Start in Edit Mode (Paused)
        togglePlayState(); // This actually starts it
        togglePlayState(); // Toggle back to Pause
    </script>
</body>
</html>
